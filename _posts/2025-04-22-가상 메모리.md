---
# Header
layout: post
title: "기억장치 관리 / with. 가상 메모리"
date: "2025-04-22"
categories:
  - CS
tags: 
  - "2025"
  - "CS"
image: "/assets/img/thumbnail/virtualmemory.jpg"
toc: true
toc_sticky: true
---

### 한 줄 요약
- 가상 메모리는 보조기억장치 자체가 아니라, OS가 보조기억장치와 주기억장치를 포함하여 관리하는 **논리적 메모리 시스템**을 말한다.

### 기억장치 관리
우리가 어떤 프로그램을 다운 받으면 그 프로그램은 보조기억장치에 저장된다. (주기억장치의 용량은 작기 때문에.) 
그 후 프로그램을 실행하면 OS는 PCB를 생성하며 해당 프로세스를 일정한 크기로 나눠서 메모리에 올린다.
프로세스가 생성된 이후부터 이걸 관리하는건 OS의 역할이다. 그럼 OS는 프로세스를 메모리에 "어떻게" 올릴까?

일단, OS는 프로세스가 생성되면 해당 프로세스에 있는 데이터들을 바로 메모리에 올리지 않는다.

OS는 프로세스가 생성되면 
1. 해당 프로세스의 가상 주소 공간을 생성한다.
2. 실제 실행 코드와 데이터는 보조기억장치(디스크)에 존재한다. [참고](https://dpwls02142.github.io/posts/itertools-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC%EC%99%80-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B5%AC%EC%A1%B0/#%EA%B7%B8%EB%9F%BC-ram%EC%97%90-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%A0%81%EC%9E%AC%EA%B0%80-%EB%90%98%EB%8A%94%EA%B0%80)
3. 해당 페이지가 필요할 때만 RAM으로 불러오는 방식이 사용된다.

크롬으로 여러 탭을 띄우고 있다고하자. 이 때 나는 A라는 탭만 사용하고 있고, B라는 탭은 사용하지 않고 있다. 그럼 내가 현재 사용하고 있는 데이터는 현재 보고 있는 탭의 내용만 실제로 사용하고 있는거다. 즉, 다른 탭의 내용이나 백그라운드 기능들은 당장 사용하지 않고 있는 상태이다. 근데 이 모든걸 한꺼번에 메모리에 바로 올린다면? 메모리 공간이 넘쳐나지 않는 이상 문제가 발생할거다.

따라서 현재 사용 중인 부분만 실제 메모리에 올리고 (스왑인), 사용하지 않는 부분은 가상메모리 공간에 위치시칸다(스왑아웃).

이러한 가상메모리를 OS가 어떻게 구현하는가? 하면 이는 페이징과 세그먼테이션 기법으로 나눌 수 있다.
1. 페이징 기법
	1. 프로세스의 데이터를 페이지 단위의 "고정적인 크기"로 나눠서 데이터를 관리한다.
	2. 왜 Page라는 단어를 썼을까 생각해봤을 때, 우리가 사용하는 종이의 사이즈가 A4면 A4고 B4면 B4듯이, 종이 사이즈는 고정적인 크기를 갖지 않는가? 그래서 page라고 한 것 같다.
	3. 근데 내부 단편화가 일어날 수 있다.
		1. 먼저 단편화란, 낭비되는 공간을 의미한다. 따라서 내부 단편화란, 페이지가 프로세스의 실제 필요 공간보다 클 경우에 발생하는 낭비된 공간을 의미한다. 내부라고 표현하는 이유는 페이지의 내부에서 공간이 낭비되기 때문에 내부 단편화라고 하는거다.
2. 세그먼테이션 기법
	1. 프로세스의 데이터를 논리적인 구조 (코드, 데이터, 힙, 스택)로 나눠서 가변적으로 사용하는 것을 말한다.
	2. 하지만 외부 단편화가 일어날 수 있다.
		1. 외부 단편화란 단편화가 할당된 메모리 블록들 사이, 즉 외부에 서 발생하기 때문에 외부 단편화라고 표현한다. 즉 가상메모리의 전체 빈 공간은 넘치지만 이를 사용하지 못하는거다. 

그럼 페이징은 언제 쓰이고, 세그먼테이션은 언제 쓰이는걸까 하고 찾아봤다. 근데 현대의 OS는 가상메모리공간을 구현할 때 "순수한" 세그먼테이션을 사용하지 않는다고 한다. 

<p align="center"><a href="https://stackoverflow.com/questions/24358105/do-modern-oss-use-paging-and-segmentation"><img src= "/assets/img/posts/250422/1.png" alt="dd"></a></p>
<p align="center" style="color:#c3c4ca;">이미지를 누르면 원본 사이트로 이동된다.</p>

왜냐면 외부 단편화가 심각한 문제이며 세그먼테이션은 페이지와 달리 크기가 가변적이기에 관리하기도 힘들기 때문이다.

따라서 현재는 세그먼테이션 기법에서 사용되는 논리적인 구조(코드, 데이터, 스택, 힙)들 마저 내부 구조는 페이지 단위로 구현이 되어있다고 한다.

결론적으로 현대 OS는 세그먼테이션과 페이징을 혼합해서 사용하고 있긴 하지만, 내부까지 들여다 봐서 엄밀히 말하면 세그먼테이션은 사용하지 않고 있다고 할 수 있다.

다음으로, 가상메모리를 관리하는 단계로는 반입, 배치, 교체 단계가 있다.
1. **반입 (Fetch) 단계**
	- 가상 메모리를 "언제" RAM에 위치시킬지, 그 타이밍을 정한다.

2. **배치 (Placement) 단계**
	- 데이터가 들어갈 수 있는 상태일 때 ( == 상태가 사용 중이거나 영역 크기가 데이터 크기보다 작으면 안됨.)
	1. **worst** fit: 단편화를 가장 **많이** 남기는 분할 영역에 배치하는 방식이다.
	2. **best** fit: 단편화를 가장 **작게** 남기는 분할 영역에 배치하는 방식이다.
	3. **first** fit: **첫번째** 분할 영역에 배치하는 방식이다.

3. **교체 (Replacement) 단계**
	- **페이지 부재(Page Fault)**는 CPU가 요청한 데이터나 명령어가 RAM에 없는 경우 발생하는 현상이다.
	- 이때 RAM이 꽉 차 있으면 기존 페이지를 다른 페이지로 교체하여 공간을 확보해야 한다. (이 과정을 페이지 교체라 한다.)
	- 또한 RAM에 여유 공간이 있더라도 처음 접근하는 페이지라면 페이지 부재가 발생할 수 있다. => 최초로 처음 접근하는 데이터는 RAM에 없기 때문이다.
	- 이러한 페이지 부재가 너무 자주 발생하면, 시스템은 계속 디스크와 RAM 간에 데이터를 교체하느라 대부분의 시간을 소모하게 된다. 이러한 현상을 **스래싱(Thrashing)**이라고 한다.
		- 이 때 너무 자주라는 표현이 좀 모호할 수 있는데, 스래싱에는 임계점이 존재해서 페이지 부재율이 해당 임계점을 넘으면 스래싱이 발생했다고 본다.

	- **FIFO (First In First Out)**
	{% include embed/youtube.html id='iwAeOjBVcsw?si=inCUpxsQhMj_vhtg' %}
	- **LRU (Least Recently Update)**
	- **NRU (Not Used Recently)**