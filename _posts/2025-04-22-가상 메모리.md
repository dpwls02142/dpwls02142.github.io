---
# Header
layout: post
title: "기억장치 관리 / with. 가상 메모리"
date: "2025-04-20"
categories:
  - CS
tags: 
  - "2025"
  - "CS"
toc: true
toc_sticky: true
---

### 기억장치 관리
우리가 어떤 프로그램을 다운 받으면 그 프로그램은 보조기억장치에 저장된다. (주기억장치의 용량은 작기 때문에.) 
그 후 프로그램을 실행하면 OS는 PCB를 생성하며 해당 프로세스를 일정한 크기로 나눠서 메모리에 올린다.
프로세스가 생성된 이후부터 이걸 관리하는건 OS의 역할이다. 그럼 OS는 프로세스를 메모리에 "어떻게" 올릴까?

일단, OS는 프로세스가 생성되면 해당 프로세스에 있는 데이터들을 바로 메모리에 올리지 않는다. 보조기억장치에 가상메모리 (Virtual memory) 공간을 만들어서 이 곳에 먼저 올린 후, 진짜 필요할 때마다 주기억장치 (메모리)로 옮긴다. 왜일까?

크롬으로 여러 탭을 띄우고 있다고하자. 이 때 나는 A라는 탭만 사용하고 있고, B라는 탭은 사용하지 않고 있다. 그럼 내가 현재 사용하고 있는 데이터는 현재 보고 있는 탭의 내용만 실제로 사용하고 있는거다. 즉, 다른 탭의 내용이나 백그라운드 기능들은 당장 사용하지 않고 있는 상태이다. 근데 이 모든걸 한꺼번에 메모리에 바로 올린다면? 메모리 공간이 넘쳐나지 않는 이상 문제가 발생할거다.

따라서 현재 사용 중인 부분만 실제 메모리에 올리고 (스왑인), 사용하지 않는 부분은 가상메모리 공간에 위치시칸다(스왑아웃).

이러한 가상메모리를 OS가 어떻게 구현하는가? 하면 이는 페이징과 세그먼테이션 기법으로 나눌 수 있다.
1. 페이징 기법
	1. 프로세스의 데이터를 페이지 단위의 "고정적인 크기"로 나눠서 데이터를 관리한다.
	2. 왜 Page라는 단어를 썼을까 생각해봤을 때, 우리가 사용하는 종이의 사이즈가 A4면 A4고 B4면 B4듯이, 종이 사이즈는 고정적인 크기를 갖지 않는가? 그래서 page라고 한 것 같다.
	3. 근데 내부 단편화가 일어날 수 있다.
		1. 먼저 단편화란, 낭비되는 공간을 의미한다. 따라서 내부 단편화란, 페이지가 프로세스의 실제 필요 공간보다 클 경우에 발생하는 낭비된 공간을 의미한다. 내부라고 표현하는 이유는 페이지의 내부에서 공간이 낭비되기 때문에 내부 단편화라고 하는거다.
2. 세그먼테이션 기법
	1. 프로세스의 데이터를 논리적인 구조 (코드, 데이터, 힙, 스택)로 나눠서 가변적으로 사용하는 것을 말한다.
	2. 하지만 외부 단편화가 일어날 수 있다.
		1. 외부 단편화란 단편화가 할당된 메모리 블록들 사이, 즉 외부에 서 발생하기 때문에 외부 단편화라고 표현한다. 즉 가상메모리의 전체 빈 공간은 넘치지만 이를 사용하지 못하는거다. 

그럼 페이징은 언제 쓰이고, 세그먼테이션은 언제 쓰이는걸까 하고 찾아봤다. 근데 현대의 OS는 가상메모리공간을 구현할 때 "순수한" 세그먼테이션을 사용하지 않는다고 한다. 

<p align="center"><a href="https://stackoverflow.com/questions/24358105/do-modern-oss-use-paging-and-segmentation"><img src= "/assets/img/posts/250422/1.png" alt="dd"></a></p>
<p align="center" style="color:#c3c4ca;">이미지를 누르면 원본 사이트로 이동된다.</p>

왜냐면 외부 단편화가 심각한 문제이며 세그먼테이션은 페이지와 달리 크기가 가변적이기에 관리하기도 힘들기 때문이다.

따라서 현재는 세그먼테이션 기법에서 사용되는 논리적인 구조(코드, 데이터, 스택, 힙)들 마저 내부 구조는 페이지 단위로 구현이 되어있다고 한다.

결론적으로 현대 OS는 세그먼테이션과 페이징을 혼합해서 사용하고 있긴 하지만, 내부까지 들여다 봐서 엄밀히 말하면 세그먼테이션은 사용하지 않고 있다고 할 수 있다.

다음으로, 가상메모리를 관리하는 단계로는 반입, 배치, 교체 단계가 있다.
1. 반입 (Fetch) 단계
	1. 가상 메모리에 "언제" 위치시킬지, 그 타이밍을 정한다. ![[Pasted image 20250421194255.png]]
		"fetch" 란 무언가를 가져오는 것을 의미한다. 고로 우리가 프로세스를 갖고오는거
2. 배치 (Placemnet) 단계
	1. worst fit
	2. best fit
	3. first fit
3. 교체 (Replace) 단계